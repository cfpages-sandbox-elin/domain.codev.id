// This file centralizes the content of all markdown documentation files.
// This approach is used because we cannot directly read from the filesystem
// in a standard Vite/React web application build.

export interface DocContent {
    slug: string;
    title: string;
    content: string;
}

const readmeContent = `
# Domain Codev

An aesthetically pleasing app to check domain availability and track domain expiration dates. It helps you renew your domains on time or snatch up expiring ones as soon as they drop, with all your data securely stored in your personal account.

![Domain Codev Screenshot](https://picsum.photos/1200/600)

## Features

*   **Secure User Accounts:** Sign in with your Google account to keep your domain list private and synced.
*   **Resilient Real-Time Domain Check:** Quickly see if a domain is available using a tiered approach with multiple fallbacks including WhoisXMLAPI, apilayer.com, whoisfreaks.com, whoapi.com, and rapidapi.com.
*   **Automated Daily Checks:** A secure, server-side Supabase Edge Function runs daily to automatically update the status of your tracked domains, checking for expirations and drops.
*   **Manual Re-check:** For any domain where the lookup failed, a simple "Re-check" button allows you to instantly try again.
*   **Direct Purchase Links:** For available domains, get quick links to recommended registrars to purchase the domain immediately.
*   **Advanced Expiration Alerts:** Get multi-level, color-coded visual alerts for domains expiring within 90, 30, and 7 days, plus a critical alert for already expired domains.
*   **Track Your Portfolio:** Add domains to a personal tracking list.
*   **Smart Tagging & Keyboard Shortcuts:** Tag domains as "Mine" or "To Snatch". Add them even faster using \`Enter\` (for Mine) and \`Shift+Enter\` (for To Snatch).
*   **Advanced Filtering:** Filter your list by tag, status, or urgency, including a dedicated "Available" filter.
*   **Drop-Catching Helper:** For expired domains, get an estimated timeline for when they might become available.
*   **Light/Dark Mode:** Beautifully designed interface that's easy on the eyes.
*   **Cloud Data Persistence:** Your list is securely saved to your Supabase account, accessible from anywhere.

## Tech Stack

*   **Vite** + **React 18** & **TypeScript**
*   **Tailwind CSS** for styling
*   **Supabase** for Authentication, Database, and Edge Functions
*   **Cron Job Schedulers**: Supabase Cron or external services (e.g., fastcron.com)
*   **\`who-dat\`** (self-hosted), **WhoisXMLAPI**, **apilayer.com API**, **whoisfreaks.com API**, **whoapi.com API**, & **rapidapi.com API** for live domain data

---

## Getting Started: Local Development

Follow these steps to set up and run the project on your local machine.

### Step 1: Clone the Repository

\`\`\`bash
git clone <repository-url>
cd <repository-directory>
\`\`\`

### Step 2: Install Dependencies

You need to have [Node.js](https://nodejs.org/) (version 18 or newer) installed.

\`\`\`bash
npm install
\`\`\`

### Step 3: Configure Environment Variables

1.  Create a new file named \`.env\` in the root of the project.
2.  Add the required variables for Supabase and the WHOIS APIs. You will need to get these keys from their respective services.

    \`\`\`env
    # Supabase Credentials (Required)
    VITE_SUPABASE_URL=YOUR_SUPABASE_PROJECT_URL
    VITE_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY

    # WHOIS API Keys (Add at least one provider for full functionality)
    VITE_WHOIS_API_KEY=YOUR_WHOISXMLAPI_KEY
    VITE_APILAYER_API_KEY=YOUR_APILAYER_KEY
    VITE_WHOISFREAKS_API_KEY=YOUR_WHOISFREAKS_KEY
    VITE_WHOAPI_COM_API_KEY=YOUR_WHOAPI_COM_KEY
    VITE_RAPIDAPI_KEY=YOUR_RAPIDAPI_KEY
    
    # Optional: Self-hosted who-dat instance for WHOIS lookups
    # The public instance is not recommended due to rate limits and CORS issues.
    # See /docs/who-dat.md for deployment instructions.
    # VITE_WHO_DAT_URL=https://your-who-dat-instance.vercel.app
    # VITE_WHO_DAT_AUTH_KEY=YOUR_WHO_DAT_SECRET_KEY
    \`\`\`

    **Note:** The \`VITE_\` prefix is required for Vite to expose these variables to the application.

### Step 4: Set Up the Database Table
(Instructions for this step are unchanged and can be found in the original \`README.md\`)
\`\`\`sql
-- Create custom types for cleaner constraints
CREATE TYPE public.domain_tag_type AS ENUM ('mine', 'to-snatch');
CREATE TYPE public.domain_status_type AS ENUM ('available', 'registered', 'expired', 'dropped', 'unknown');

-- Create the 'domains' table
CREATE TABLE public.domains (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    user_id uuid NOT NULL DEFAULT auth.uid(),
    domain_name text NOT NULL,
    tag public.domain_tag_type NOT NULL,
    status public.domain_status_type NOT NULL,
    expiration_date timestamptz NULL,
    registered_date timestamptz NULL,
    registrar text NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    last_checked timestamptz NULL,
    CONSTRAINT domains_pkey PRIMARY KEY (id),
    CONSTRAINT domains_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON DELETE CASCADE,
    CONSTRAINT domains_user_id_domain_name_key UNIQUE (user_id, domain_name)
);

-- Add comments to columns for clarity in the Supabase UI
COMMENT ON TABLE public.domains IS 'Stores domains tracked by users.';
COMMENT ON COLUMN public.domains.id IS 'Primary key for the domain entry.';
COMMENT ON COLUMN public.domains.user_id IS 'Foreign key linking to the user who owns this entry.';
COMMENT ON COLUMN public.domains.domain_name IS 'The domain name being tracked.';
COMMENT ON COLUMN public.domains.tag IS 'User-defined tag: "mine" or "to-snatch".';
COMMENT ON COLUMN public.domains.status IS 'Current status of the domain.';
COMMENT ON COLUMN public.domains.expiration_date IS 'The expiration date of the domain.';
COMMENT ON COLUMN public.domains.registered_date IS 'The registration date of the domain.';
COMMENT ON COLUMN public.domains.registrar IS 'The registrar of the domain.';
COMMENT ON COLUMN public.domains.last_checked IS 'Timestamp of the last successful WHOIS check.';
COMMENT ON COLUMN public.domains.created_at IS 'Timestamp when the domain was added to the tracker.';

-- Enable Row Level Security (RLS) for the table
ALTER TABLE public.domains ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
-- 1. Users can see their own domains
CREATE POLICY "Allow users to view their own domains"
ON public.domains
FOR SELECT
USING (auth.uid() = user_id);

-- 2. Users can insert new domains for themselves
CREATE POLICY "Allow users to insert their own domains"
ON public.domains
FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- 3. Users can update their own domains
CREATE POLICY "Allow users to update their own domains"
ON public.domains
FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- 4. Users can delete their own domains
CREATE POLICY "Allow users to delete their own domains"
ON public.domains
FOR DELETE
USING (auth.uid() = user_id);
\`\`\`

### Step 5: Run the Development Server

\`\`\`bash
npm run dev
\`\`\`

---

## Setting Up Automated Domain Checks

To enable automatic daily checks, you need to deploy and schedule the \`check-domains\` Supabase Edge Function. This is a crucial step for the app's core functionality.

### 1. Install, Link, and Set Secrets (Common First Step)

First, install the Supabase CLI, link it to your project, and set the required secrets.

\`\`\`bash
# Install the CLI
npm install supabase --save-dev

# Log in to your Supabase account
npx supabase login

# Link your local project to your remote Supabase project
npx supabase link --project-ref <your-project-ref>
\`\`\`

#### Set Secrets for the Edge Function
The Edge Function needs API keys to work. It also needs a secret key to prevent unauthorized execution.

1.  **Create a Cron Secret:** Generate a strong, random string (e.g., using a password generator). This key will authorize the cron job service to run your function, protecting it from public access.

2.  **Set the Secrets:** Run these commands in your terminal, replacing the placeholders with your actual keys and the secret you just generated.

    \`\`\`bash
    # Required: Secret to authorize the cron job
    npx supabase secrets set CRON_SECRET=YOUR_SUPER_SECRET_STRING_HERE

    # Required: WHOIS API Keys (add at least one)
    npx supabase secrets set VITE_WHOIS_API_KEY=YOUR_WHOISXMLAPI_KEY
    npx supabase secrets set VITE_APILAYER_API_KEY=YOUR_APILAYER_KEY
    npx supabase secrets set VITE_WHOISFREAKS_API_KEY=YOUR_WHOISFREAKS_KEY
    npx supabase secrets set VITE_WHOAPI_COM_API_KEY=YOUR_WHOAPI_COM_KEY
    npx supabase secrets set VITE_RAPIDAPI_KEY=YOUR_RAPIDAPI_KEY

    # Optional: Set these if you are using a self-hosted who-dat instance
    # npx supabase secrets set VITE_WHO_DAT_URL=https://your-who-dat-instance.vercel.app
    # npx supabase secrets set VITE_WHO_DAT_AUTH_KEY=YOUR_WHO_DAT_SECRET_KEY
    \`\`\`

### 2. Deploy the Edge Function

Deploy the \`check-domains\` function included in this project.

\`\`\`bash
npx supabase functions deploy check-domains
\`\`\`

After deploying, choose **one** of the following methods to schedule the job.

### Option 1: Using Supabase's Built-in Scheduler (Simple)

This is the easiest method and is great for most use cases.

1.  Navigate to your project on the [Supabase Dashboard](https://app.supabase.com).
2.  Go to **Edge Functions** in the left sidebar.
3.  Click on the **\`check-domains\`** function.
4.  You'll see a command to invoke the function with \`curl\`. It includes the necessary \`Authorization\` header with your \`service_role\` key. You can use this to trigger it, but for scheduled jobs, Supabase handles auth internally.
5.  In the function's details page, find the **"Invoke on a schedule"** section.
6.  Enter a **Name** for your job, like \`Daily Domain Check\`.
7.  In the **"Cron schedule"** input, paste \`0 0 * * *\` to run the job daily at midnight (UTC).
8.  Click **Create schedule**.

### Option 2: Using an External Cron Service (e.g., fastcron.com)

This method provides more advanced features like detailed logs and failure notifications.

1.  **Sign up for a cron service:** Create an account on a service like [fastcron.com](https://fastcron.com/).

2.  **Get your Edge Function URL:**
    *   In your Supabase Dashboard, go to **Edge Functions** and click on the \`check-domains\` function.
    *   Under "Invoke via", find and copy the **POST** URL. It will look like \`https://<project-ref>.supabase.co/functions/v1/check-domains\`.

3.  **Create a Cron Job in FastCron:**
    *   Log into your FastCron dashboard and click **"Add a cronjob"**.
    *   Fill out the form using the screenshots below as a guide:
        *   **URL to call**: Paste your Edge Function URL here.
        *   **When to call**: Select "Once a day" or enter \`0 0 * * *\` in the **Expression** field to run at midnight UTC.
        *   Expand the **"Send HTTP request"** section. **This is the most important step.**
        *   In the **HTTP headers** text area, add the following line, replacing \`YOUR_SUPER_SECRET_STRING_HERE\` with the \`CRON_SECRET\` you created earlier:
            \`\`\`
            Authorization: Bearer YOUR_SUPER_SECRET_STRING_HERE
            \`\`\`
        *   **HTTP Method**: Can be left as \`GET\` or changed to \`POST\`.
    *   Configure other settings like timeout and notifications to your liking.
    *   Click **Save change**.

Your application is now fully configured to automatically monitor your domains every day.
`;

const deploymentContent = `
# Deployment Guide: Domain Codev on Cloudflare Pages

This guide provides step-by-step instructions for deploying the Domain Codev application to Cloudflare Pages.

## Prerequisites

1.  A Cloudflare account.
2.  A GitHub account with the application code pushed to a repository.
3.  All required API keys and Supabase credentials (see the main \`README.md\` for setup context).

## Deployment Steps

(Steps 1-5 for deploying the frontend application remain unchanged and can be found in the original \`deployment.md\`)

### Step 1: Push Your Code to GitHub
### Step 2: Create a Cloudflare Pages Project
### Step 3: Configure Build Settings
### Step 4: Add Environment Variables
### Step 5: Deploy the Application

---

## Setting Up Automated Domain Checks (Post-Deployment)

To enable automatic daily checks, you need to deploy and schedule the \`check-domains\` Supabase Edge Function. This is a crucial step for the app's core functionality.

### 1. Install, Link, and Set Secrets (Common First Step)

First, install the Supabase CLI on your local machine, link it to your project, and set the required secrets.

\`\`\`bash
# Install the CLI if you haven't already
npm install supabase --save-dev

# Log in to your Supabase account
npx supabase login

# Link your local project to your remote Supabase project
npx supabase link --project-ref <your-project-ref>
\`\`\`

#### Set Secrets for the Edge Function
The Edge Function needs API keys to work. It also needs a secret key to prevent unauthorized execution.

1.  **Create a Cron Secret:** Generate a strong, random string (e.g., using a password generator). This key will authorize the cron job service to run your function, protecting it from public access.

2.  **Set the Secrets:** Run these commands in your terminal, replacing the placeholders with your actual keys and the secret you just generated.

    \`\`\`bash
    # Required: Secret to authorize the cron job
    npx supabase secrets set CRON_SECRET=YOUR_SUPER_SECRET_STRING_HERE

    # Required: WHOIS API Keys (add at least one)
    npx supabase secrets set VITE_WHOIS_API_KEY=YOUR_WHOISXMLAPI_KEY
    npx supabase secrets set VITE_APILAYER_API_KEY=YOUR_APILAYER_KEY
    npx supabase secrets set VITE_WHOISFREAKS_API_KEY=YOUR_WHOISFREAKS_KEY
    npx supabase secrets set VITE_WHOAPI_COM_API_KEY=YOUR_WHOAPI_COM_KEY
    npx supabase secrets set VITE_RAPIDAPI_KEY=YOUR_RAPIDAPI_KEY

    # Optional: Set these if you are using a self-hosted who-dat instance
    # npx supabase secrets set VITE_WHO_DAT_URL=https://your-who-dat-instance.vercel.app
    # npx supabase secrets set VITE_WHO_DAT_AUTH_KEY=YOUR_WHO_DAT_SECRET_KEY
    \`\`\`

### 2. Deploy the Edge Function

Deploy the \`check-domains\` function from your local machine to Supabase.

\`\`\`bash
npx supabase functions deploy check-domains
\`\`\`

After deploying, choose **one** of the following methods to schedule the job.

### Option 1: Using Supabase's Built-in Scheduler (Simple)

This is the easiest method and is great for most use cases.

1.  Navigate to your project on the [Supabase Dashboard](https://app.supabase.com).
2.  Go to **Edge Functions** in the left sidebar.
3.  Click on the **\`check-domains\`** function.
4.  In the function's details page, find the **"Invoke on a schedule"** section.
5.  Enter a **Name** for your job, like \`Daily Domain Check\`.
6.  In the **"Cron schedule"** input, paste \`0 0 * * *\` to run the job daily at midnight (UTC).
7.  Click **Create schedule**.

### Option 2: Using an External Cron Service (e.g., fastcron.com)

This method provides more advanced features like detailed logs and failure notifications.

1.  **Sign up for a cron service:** Create an account on a service like [fastcron.com](https://fastcron.com/).

2.  **Get your Edge Function URL:**
    *   In your Supabase Dashboard, go to **Edge Functions** and click on the \`check-domains\` function.
    *   Under "Invoke via", find and copy the **POST** URL. It will look like \`https://<project-ref>.supabase.co/functions/v1/check-domains\`.

3.  **Create a Cron Job in FastCron:**
    *   Log into your FastCron dashboard and click **"Add a cronjob"**.
    *   Fill out the form:
        *   **URL to call**: Paste your Edge Function URL here.
        *   **When to call**: Select "Once a day" or enter \`0 0 * * *\` in the **Expression** field to run at midnight UTC.
        *   Expand the **"Send HTTP request"** section. **This is the most important step.**
        *   In the **HTTP headers** text area, add the following line, replacing \`YOUR_SUPER_SECRET_STRING_HERE\` with the \`CRON_SECRET\` you created earlier:
            \`\`\`
            Authorization: Bearer YOUR_SUPER_SECRET_STRING_HERE
            \`\`\`
        *   **HTTP Method**: Can be left as \`GET\` or changed to \`POST\`.
    *   Configure other settings like timeout and notifications to your liking.
    *   Click **Save change**.

Your application is now fully deployed and configured for automated daily checks.

---

## Supabase Configuration & Troubleshooting

(This section on troubleshooting common Supabase issues like login redirects and provider errors remains unchanged and can be found in the original \`deployment.md\`)
`;

const whoDatContent = `
# \`who-dat\` Free & Open Source WHOIS Service

This document summarizes the key details for integrating \`who-dat\`, a free and open-source WHOIS lookup service. It's an excellent primary WHOIS provider as it can be self-hosted for free.

<div style="background-color: #fffbe6; border-left: 4px solid #facc15; padding: 1rem; margin-bottom: 1rem;">
  <p style="font-weight: bold; color: #713f12;">Important Notice</p>
  <p style="color: #713f12;">
    The public instance at <code>https://who-dat.as93.net</code> is **not recommended for production use**. It is frequently rate-limited and does not send the necessary CORS headers, which will cause requests from a web application to fail. For reliable WHOIS lookups, you **must** self-host your own instance of <code>who-dat</code>.
  </p>
</div>

## Overview

\`who-dat\` provides a simple, no-CORS, no-auth (by default) API for fetching WHOIS records.

-   **Public API Base URL**: \`https://who-dat.as93.net\` (For testing only, not for app integration)
-   **Self-Hosted URL**: Your own custom domain (e.g., from a Vercel deployment). **This is the recommended approach.**

## Endpoints

-   **Single Domain Lookup**: \`/[domain]\`
    -   Example: \`https://your-own-instance.com/example.com\`
-   **Multiple Domain Lookup**: \`/multi\`
-   **API Specification**: A full OpenAPI/Swagger spec is available at the root of the deployed instance for interactive testing.

## Authentication (Optional)

Authentication is optional and can be enabled by setting the \`AUTH_KEY\` environment variable in your hosting environment (e.g., Vercel).

-   If \`AUTH_KEY\` is set, requests must include it in the \`Authorization\` header.
-   **Supported Formats**:
    -   \`Authorization: your-secret-key\`
    -   \`Authorization: Bearer your-secret-key\`
-   If \`AUTH_KEY\` is not set, the API remains public.

## Deployment (Recommended)

Self-hosting is the recommended approach for stability and privacy.

-   **Option 1: Vercel (Easiest)**
    1.  Fork the [official repository](https://github.com/Lissy93/who-dat).
    2.  Import the forked repository into your Vercel account.
    3.  Vercel will automatically deploy it. No configuration is needed for a basic setup.
    4.  Use the **1-Click Deploy Button** on the GitHub page for an even faster setup.

-   **Option 2: Docker**
    -   A pre-built Docker image is available on DockerHub and GHCR.
    -   Run the container with: \`docker run -p 8080:8080 lissy93/who-dat\`

## Response Data

The API returns a JSON object with WHOIS information. Key fields include:

-   \`domainName\`: The queried domain.
-   \`isAvailable\`: A boolean indicating if the domain can be registered.
-   \`dates\`: An object containing...
    -   \`created\`: The registration date (ISO 8601 format).
    -   \`expiry\`: The expiration date (ISO 8601 format).
-   \`registrar\`: An object containing...
    -   \`name\`: The name of the registrar.
-   \`error\`: An error message if the lookup failed.
`;

const whoisXmlApiContent = `
# WhoisXMLAPI.com WHOIS Service Documentation

This document summarizes the key details for integrating the WhoisXMLAPI.com WHOIS Web Service.

## Overview

The service provides WHOIS registration data for domain names, IP addresses, and email addresses via a RESTful API.

-   **Endpoint**: \`https://www.whoisxmlapi.com/whoisserver/WhoisService\`
-   **Methods**: Supports \`GET\` (with query parameters) and \`POST\` (with a JSON body).
-   **Response Formats**: \`JSON\` or \`XML\`.

## Authentication

Authentication is required for every request.

-   **Method 1 (Recommended): Query Parameter**
    -   Add \`apiKey=YOUR_API_KEY\` to the request URL.
    -   Example: \`.../WhoisService?apiKey=at_xxx&domainName=google.com\`

-   **Method 2: Authorization Header**
    -   Use the \`Authorization\` header with a Bearer token.
    -   Format: \`Authorization: Bearer YOUR_API_KEY\`

> The \`apiKey\` query parameter has higher priority and will be used if both methods are present.

## Key Request Parameters

### Required

-   \`domainName\` (string): The domain name, IP address, or email to look up.

### Important Optional Parameters

-   \`outputFormat\` (string): The desired response format.
    -   **Value**: \`JSON\` (Recommended for web apps)
    -   **Default**: \`XML\`
-   \`da\` (integer): Checks domain availability.
    -   **Value**: \`2\` (Slower but more accurate check)
    -   **Default**: \`0\`
    -   The result is in the \`WhoisRecord.domainAvailability\` field (\`AVAILABLE\` or \`UNAVAILABLE\`).
-   \`_hardRefresh\` (integer): Forces a real-time lookup, bypassing the cache.
    -   **Value**: \`1\`
    -   **Note**: This costs 5 API credits per call. Use sparingly.
    -   **Default**: \`0\`

## Example Request (GET)

To get an accurate availability check for \`example.com\` in JSON format:

\`\`\`
https://www.whoisxmlapi.com/whoisserver/WhoisService?apiKey=YOUR_API_KEY&domainName=example.com&outputFormat=JSON&da=2
\`\`\`

## Response Data

When requesting JSON, the response contains a \`WhoisRecord\` object. Key fields to look for include:

-   \`WhoisRecord.domainName\`: The domain that was queried.
-   \`WhoisRecord.domainAvailability\`: \`AVAILABLE\` or \`UNAVAILABLE\`.
-   \`WhoisRecord.registryData.createdDate\`: Registration date (ISO 8601 format).
-   \`WhoisRecord.registryData.expiresDate\`: Expiration date (ISO 8601 format).
-   \`WhoisRecord.registrarName\`: The name of the registrar (e.g., "GoDaddy.com, LLC").
-   \`ErrorMessage\`: If an error occurs (e.g., invalid domain), this object will be present.
`;

const apiLayerContent = `
# apilayer.com Whois API Documentation

This document summarizes the key details for integrating the apilayer.com Whois API.

## Overview

The service provides WHOIS data for domain names via a RESTful API.

-   **Endpoint**: \`https://api.apilayer.com/whois/check\`
-   **Method**: \`GET\`
-   **Response Format**: \`JSON\`

## Authentication

Authentication is required for every request and is handled via a custom HTTP header.

-   **Header Name**: \`apikey\`
-   **Usage**: All requests must include the header \`apikey: YOUR_API_KEY\`.
-   **Security**: API keys must be kept secure and should not be exposed in client-side code. Use environment variables on the server or build environment.

## Request Parameters

-   \`domain\` (string, **required**): The domain name to look up. This is passed as a query string parameter.

## Example Request (cURL)

\`\`\`bash
curl --location --request GET 'https://api.apilayer.com/whois/check?domain=example.com' \\
--header 'apikey: YOUR_API_KEY'
\`\`\`

## Rate Limiting

-   Each subscription plan has daily and monthly rate limits.
-   When a limit is reached, the API will respond with an \`HTTP 429 Too Many Requests\` status code.
-   The response body for a rate-limited request will be:
    \`\`\`json
    {
        "message": "You have exceeded your daily/monthly API rate limit..."
    }
    \`\`\`
-   You can programmatically check your remaining limits via the following response headers sent with every successful request:
    -   \`x-ratelimit-limit-month\`: Your monthly request quota.
    -   \`x-ratelimit-remaining-month\`: Requests remaining this month.
    -   \`x-ratelimit-limit-day\`: Your daily request quota.
    -   \`x-ratelimit-remaining-day\`: Requests remaining today.

## Error Codes

The API uses standard HTTP status codes to indicate success or failure. A non-200 response indicates an error, and the JSON body will contain a \`message\` field with details.

-   **\`400 - Bad Request\`**: A required parameter (like \`domain\`) is missing or invalid.
-   **\`401 - Unauthorized\`**: The provided \`apikey\` is missing or invalid.
-   **\`404 - Not Found\`**: The requested resource does not exist.
-   **\`429 - Too many requests\`**: You have exceeded your API rate limit.
-   **\`5xx - Server Error\`**: An error occurred on apilayer's servers.
`;

const whoisFreaksContent = `
# WhoisFreaks.com WHOIS API Documentation

This document summarizes the key details for integrating the WhoisFreaks.com live WHOIS API.

## Overview

The service provides real-time ("live") WHOIS data for a given domain name via a RESTful API.

-   **Endpoint**: \`https://api.whoisfreaks.com/v1.0/whois\`
-   **Method**: \`GET\`
-   **Response Formats**: \`JSON\` (default) or \`XML\`.

## Authentication

Authentication is required for every request and is handled via a query parameter.

-   **Parameter Name**: \`apiKey\`
-   **Usage**: All requests must include \`apiKey=YOUR_API_KEY\` in the URL's query string.
-   **Security**: You can reset your API key from the billing dashboard if it is ever compromised.

## Key Request Parameters

### Required

-   \`apiKey\` (string): Your personal API key from the WhoisFreaks dashboard.
-   \`whois\` (string): Must be set to the value \`live\` for real-time lookups.
-   \`domainName\` (string): The domain name you want to query.

### Optional

-   \`format\` (string): The desired response format.
    -   **Values**: \`JSON\` | \`XML\`
    -   **Default**: \`JSON\`

## Example Request (GET)

To get live WHOIS data for \`whoisfreaks.com\` in the default JSON format:

\`\`\`
https://api.whoisfreaks.com/v1.0/whois?apiKey=YOUR_API_KEY&whois=live&domainName=whoisfreaks.com
\`\`\`

## Response Data

A successful response (HTTP 200) returns a JSON object. Key fields to look for include:

-   \`status\`: \`true\` on success.
-   \`domain_name\`: The domain that was queried.
-   \`domain_registered\`: \`"yes"\` or \`"no"\`.
-   \`create_date\`: Registration date (e.g., "2019-03-19").
-   \`expiry_date\`: Expiration date (e.g., "2025-03-19").
-   \`domain_registrar\`: An object containing...
    -   \`registrar_name\`: The name of the registrar (e.g., "NAMECHEAP INC").
-   \`error\`: If the \`status\` is \`false\`, this object may contain an error message.

## Error Handling

The API uses standard HTTP status codes to indicate issues. For example:

-   **\`400\`**: Invalid domain name.
-   **\`401\`**: Invalid or inactive API key, or insufficient credits.
-   **\`408\`**: Unable to fetch WHOIS data for the domain.
-   **\`429\`**: Maximum request limit reached.
`;

const whoapiContent = `
# WhoAPI.com WHOIS Service Documentation

This document summarizes the key details for integrating the WhoAPI.com WHOIS service.

## Overview

The service provides parsed WHOIS registration data for domain names programmatically.

-   **Endpoint**: \`http://api.whoapi.com/\`
-   **Method**: \`GET\`
-   **Response Format**: \`JSON\` (default) or \`XML\`.

## Authentication

Authentication is required for every request and is handled via a query parameter.

-   **Parameter Name**: \`apikey\`
-   **Usage**: All requests must include \`apikey=YOUR_API_KEY\` in the URL's query string.

## Key Request Parameters

### Required

-   \`apikey\` (string): Your personal API key from the WhoAPI dashboard.
-   \`r\` (string): Must be set to the value \`whois\` for a parsed WHOIS lookup.
-   \`domain\` (string): The domain name you want to query.

## Example Request (GET)

To get parsed WHOIS data for \`example.com\` in JSON format:

\`\`\`
http://api.whoapi.com/?domain=example.com&r=whois&apikey=YOUR_API_KEY
\`\`\`

## Response Data

A successful response (\`status: "0"\`) returns a JSON object. Key fields to look for include:

-   \`status\`: A string code. \`"0"\` indicates success.
-   \`registered\`: A boolean (\`true\` or \`false\`) indicating if the domain is registered.
-   \`date_created\`: Registration date (e.g., "2011-02-14 15:31:26").
-   \`date_expires\`: Expiration date (e.g., "2021-02-14 15:31:26").
-   \`whois_name\`: The name of the registrar (e.g., "PublicDomainRegistry").
-   \`contacts\`: An array of contact objects. The registrar's full name can often be found in the contact object where \`type\` is \`"registrar"\`.
-   \`requests_available\`: Your remaining API request quota.

## Error Handling

If a request fails, the \`status\` field will contain a non-zero value, and \`status_desc\` will provide a human-readable error message.
`;

const rapidApiContent = `
# RapidAPI Domain WHOIS Lookup API Documentation

This document summarizes the key details for integrating the RapidAPI Domain WHOIS Lookup API.

## Overview

The service provides WHOIS data for any registered domain name via a RESTful API.

-   **Endpoint**: \`https://domain-whois-lookup-api.p.rapidapi.com/whois\`
-   **Method**: \`GET\`
-   **Response Format**: \`JSON\`

## Authentication

Authentication is required for every request and is handled via custom HTTP headers.

-   **Host Header**: \`x-rapidapi-host: domain-whois-lookup-api.p.rapidapi.com\`
-   **API Key Header**: \`x-rapidapi-key: YOUR_RAPIDAPI_KEY\`

You must subscribe to the API on the [RapidAPI Marketplace](https://rapidapi.com/is-this-thing-on/api/domain-whois-lookup-api) to get your key.

## Request Parameters

-   \`domain_name\` (string, **required**): The domain name to look up, passed as a query string parameter.

## Example Request (cURL)

\`\`\`bash
curl --request GET \\
	--url 'https://domain-whois-lookup-api.p.rapidapi.com/whois?domain_name=example.com' \\
	--header 'x-rapidapi-host: domain-whois-lookup-api.p.rapidapi.com' \\
	--header 'x-rapidapi-key: YOUR_RAPIDAPI_KEY'
\`\`\`

## Response Data

A successful response returns a JSON object with the following key fields:

-   \`name\`: The name of the domain.
-   \`creation_date\`: The date when the domain was first registered (ISO 8601 format).
-   \`expiration_date\`: The date when the domain registration will expire (ISO 8601 format).
-   \`registrar\`: The name of the domain registrar.
-   \`registrant\`: The name of the domain registrant.
-   \`email\`: The email address of the domain registrant.

## Error Handling

The API uses standard HTTP status codes.

-   **\`400 - Bad Request\`**: An invalid domain name was provided. The response body will contain an error message.
    \`\`\`json
    { "error": "Invalid domain name" }
    \`\`\`
-   **\`404 - Not Found\`**: The domain is not found, which indicates it is available for registration. The response body will be:
    \`\`\`json
    { "status": "Available for registration" }
    \`\`\`

## Rate Limiting

-   The API limits requests to 1000 requests per day per IP address on the free (BASIC) plan.
`;


const troubleshootingContent = `
# Troubleshooting Guide

This document covers common issues and their solutions when working with this project.

## Issue: Build fails with TypeScript errors in \`DocsPage.tsx\`

You may encounter a series of build errors related to the \`marked\` library, like this:

\`\`\`
src/components/DocsPage.tsx(19,17): error TS2322: Type '(text: any, level: any) => string' is not assignable to type '({ tokens, depth }: Heading) => string'.
\`\`\`

### The Problem: API and Type Definition Mismatch

This error occurs due to a mismatch between the JavaScript implementation of the \`marked\` library and its corresponding TypeScript type definitions (\`@types/marked\`).

The \`marked\` library has evolved, and there are two primary ways to customize its HTML output:

1.  **The "Old" Way (Instance-based):** You create a new renderer instance (\`new marked.Renderer()\`) and override its methods. The functions for this method take simple arguments, like \`renderer.heading = function(text, level) { ... }\`. This is how the code was originally written.

2.  **The "New" Way (Extension API):** You pass a plain JavaScript object with renderer functions to \`marked.use({ renderer: ... })\`. The functions for this newer method receive a single complex **token object**, like \`heading(token) { ... }\`.

The problem is that the official TypeScript types for recent versions of \`marked\` **only describe the new, token-based API**. When the TypeScript compiler sees the old, argument-based functions in the code, it flags them as errors because they don't match the token-based signatures in the type definitions.

### The Solution: Extend the Renderer Class

The most robust and type-safe way to resolve this is to adopt the modern approach that aligns with the TypeScript types. While the extension API (\`marked.use()\`) is one option, an even better solution is to **extend the \`marked.Renderer\` class**.

This approach has a significant advantage: it provides access to the renderer's internal parser via \`this.parser\`. This is crucial for correctly rendering nested markdown elements (e.g., a link inside a paragraph or bold text in a list item), a task that is very difficult with the other methods.

#### Correct Implementation (\`src/components/DocsPage.tsx\`)

\`\`\`tsx
import { marked } from 'marked';
import type { Tokens } from 'marked';

// 1. Create a custom class that extends the base renderer
class CustomRenderer extends marked.Renderer {
    // 2. Override methods using the correct token-based signatures
    heading(token: Tokens.Heading): string {
        // 3. Use the internal parser to correctly render nested content
        const text = this.parser.parseInline(token.tokens || []);
        const level = token.depth;
        // ... apply custom styling
        return \`<h\${level} class="...">\${text}</h\${level}>\`;
    }

    // ... other overrides ...
}

// 4. In the component, use an instance of the new custom renderer
useEffect(() => {
    const parseMarkdown = async () => {
        // ...
        const renderer = new CustomRenderer();
        const rawHtml = await marked.parse(selectedDoc.content, { async: true, renderer });
        setHtmlContent(rawHtml);
        // ...
    };
    parseMarkdown();
}, [selectedDoc]);
\`\`\`

This pattern resolves all the build errors, ensures type safety, and correctly renders the documentation with the desired custom styling.

---

## Issue: Supabase TypeScript errors like "Type instantiation is excessively deep"

You might encounter TypeScript errors in \`src/services/supabaseService.ts\` when using the Supabase client, with messages like:

\`\`\`
Type instantiation is excessively deep and possibly infinite.
\`\`\`
or errors related to \`Insert<"domains">\` or \`Update<"domains">\`.

### The Problem: Mismatch between Database Schema and TypeScript Types

This error is a classic sign that the TypeScript types used by the Supabase client are out of sync with your actual database schema. In this project, it's specifically caused by using custom \`ENUM\` types in the database (\`domain_tag_type\` and \`domain_status_type\`) without telling the Supabase client what those types are.

When the \`createClient\` function is typed with our \`Database\` interface, TypeScript tries to infer the types for \`insert\`, \`update\`, and \`select\` operations. If it encounters a type from the database (like \`domain_tag_type\`) that isn't defined in the \`Enums\` section of the \`Database\` interface, it can't resolve the type and enters a recursive loop, resulting in the "excessively deep" error.

### The Solution: Align Your Types with the Database Schema

There are two ways to fix this. The first is a manual fix that solves the immediate problem. The second is the recommended, long-term solution using the Supabase CLI.

#### 1. Manual Fix (The Quick Fix)

You can manually update the \`Database\` interface in \`src/services/supabaseService.ts\` to include the definitions for your custom ENUM types.

**\`src/services/supabaseService.ts\`**
\`\`\`typescript
// ... import DomainTag, DomainStatus from '../types' ...

export interface Database {
  public: {
    // ... Tables, Views, Functions ...
    Enums: {
      // Add these two lines
      domain_status_type: DomainStatus;
      domain_tag_type: DomainTag;
    };
    // ... CompositeTypes ...
  };
}
\`\`\`

This tells TypeScript what \`'mine' | 'to-snatch'\` and the other status strings are valid for these enum types, resolving the error. This is the fix that has been applied to the codebase.

#### 2. Recommended Solution: Generate Types with Supabase CLI

The best practice for keeping your database and application types in sync is to let the Supabase CLI generate the types for you directly from your schema. This eliminates manual errors and makes it easy to update types whenever you change your database.

**Step 1: Generate the Type File**
Run the following command in your project's root directory. Make sure you have linked your project with \`npx supabase link\`.

\`\`\`bash
# For local development
npx supabase gen types typescript --local > src/types/supabase.ts

# For a remote project
npx supabase gen types typescript --project-id <your-project-id> > src/types/supabase.ts
\`\`\`

This command inspects your database schema and creates a file \`src/types/supabase.ts\` containing all the necessary interfaces, including your custom enums.

**Step 2: Use the Generated Types**
Now, modify \`src/services/supabaseService.ts\` to use these generated types.

\`\`\`typescript
// src/services/supabaseService.ts
import { createClient, Session, SupabaseClient } from '@supabase/supabase-js';
// 1. Import the generated Database type
import { Database } from '../types/supabase'; // Adjust path if needed

// We no longer need to manually define the Database interface here.
// The rest of the file can use the imported \`Database\` type.

// ...

// 2. The createClient call is now correctly typed from the generated file.
const supabaseInstance = createClient<Database>(supabaseUrl, supabaseAnonKey);
\`\`\`

By adopting this workflow, you ensure your application's type safety and prevent this category of errors from happening again.
`;


export const docs: DocContent[] = [
    {
        slug: 'readme',
        title: 'Project Overview',
        content: readmeContent
    },
    {
        slug: 'deployment',
        title: 'Deployment & Setup',
        content: deploymentContent
    },
    {
        slug: 'troubleshooting',
        title: 'Troubleshooting',
        content: troubleshootingContent
    },
    {
        slug: 'who-dat',
        title: 'Provider: who-dat',
        content: whoDatContent
    },
    {
        slug: 'whoisxmlapi',
        title: 'Provider: WhoisXMLAPI',
        content: whoisXmlApiContent
    },
    {
        slug: 'apilayer',
        title: 'Provider: apilayer.com',
        content: apiLayerContent
    },
    {
        slug: 'whoisfreaks',
        title: 'Provider: WhoisFreaks',
        content: whoisFreaksContent
    },
    {
        slug: 'whoapi',
        title: 'Provider: WhoAPI.com',
        content: whoapiContent
    },
    {
        slug: 'rapidapi',
        title: 'Provider: RapidAPI',
        content: rapidApiContent
    },
];